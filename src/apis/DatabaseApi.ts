/* tslint:disable */
/* eslint-disable */
/**
 * tensors
 * API for CivitAI model management and image gallery
 *
 * The version of the OpenAPI document: 0.1.18
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { CacheRequest, HTTPValidationError, ScanRequest } from '../models/index'
import {
  CacheRequestFromJSON,
  CacheRequestToJSON,
  HTTPValidationErrorFromJSON,
  HTTPValidationErrorToJSON,
  ScanRequestFromJSON,
  ScanRequestToJSON,
} from '../models/index'
import * as runtime from '../runtime'

export interface CacheModelApiDbCachePostRequest {
  cacheRequest: CacheRequest
}

export interface GetFileApiDbFilesFileIdGetRequest {
  fileId: number
}

export interface GetModelApiDbModelsCivitaiIdGetRequest {
  civitaiId: number
}

export interface GetTriggersByPathApiDbTriggersGetRequest {
  filePath: string
}

export interface GetTriggersByVersionApiDbTriggersVersionIdGetRequest {
  versionId: number
}

export interface ScanDirectoryApiDbScanPostRequest {
  scanRequest: ScanRequest
}

export interface SearchModelsApiDbModelsGetRequest {
  query?: string | null
  type?: string | null
  base?: string | null
  limit?: number
}

/**
 *
 */
export class DatabaseApi extends runtime.BaseAPI {
  /**
   * Fetch and cache full CivitAI model data.
   * Cache Model
   */
  async cacheModelApiDbCachePostRaw(
    requestParameters: CacheModelApiDbCachePostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: any }>> {
    if (requestParameters['cacheRequest'] == null) {
      throw new runtime.RequiredError(
        'cacheRequest',
        'Required parameter "cacheRequest" was null or undefined when calling cacheModelApiDbCachePost().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    const urlPath = `/api/db/cache`

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CacheRequestToJSON(requestParameters['cacheRequest']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Fetch and cache full CivitAI model data.
   * Cache Model
   */
  async cacheModelApiDbCachePost(
    requestParameters: CacheModelApiDbCachePostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<{ [key: string]: any }> {
    const response = await this.cacheModelApiDbCachePostRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get local file by ID.
   * Get File
   */
  async getFileApiDbFilesFileIdGetRaw(
    requestParameters: GetFileApiDbFilesFileIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: any }>> {
    if (requestParameters['fileId'] == null) {
      throw new runtime.RequiredError(
        'fileId',
        'Required parameter "fileId" was null or undefined when calling getFileApiDbFilesFileIdGet().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    let urlPath = `/api/db/files/{file_id}`
    urlPath = urlPath.replace(
      `{${'file_id'}}`,
      encodeURIComponent(String(requestParameters['fileId'])),
    )

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Get local file by ID.
   * Get File
   */
  async getFileApiDbFilesFileIdGet(
    requestParameters: GetFileApiDbFilesFileIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<{ [key: string]: any }> {
    const response = await this.getFileApiDbFilesFileIdGetRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get cached model by CivitAI ID.
   * Get Model
   */
  async getModelApiDbModelsCivitaiIdGetRaw(
    requestParameters: GetModelApiDbModelsCivitaiIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: any }>> {
    if (requestParameters['civitaiId'] == null) {
      throw new runtime.RequiredError(
        'civitaiId',
        'Required parameter "civitaiId" was null or undefined when calling getModelApiDbModelsCivitaiIdGet().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    let urlPath = `/api/db/models/{civitai_id}`
    urlPath = urlPath.replace(
      `{${'civitai_id'}}`,
      encodeURIComponent(String(requestParameters['civitaiId'])),
    )

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Get cached model by CivitAI ID.
   * Get Model
   */
  async getModelApiDbModelsCivitaiIdGet(
    requestParameters: GetModelApiDbModelsCivitaiIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<{ [key: string]: any }> {
    const response = await this.getModelApiDbModelsCivitaiIdGetRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Get database statistics.
   * Get Stats
   */
  async getStatsApiDbStatsGetRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: any }>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    const urlPath = `/api/db/stats`

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Get database statistics.
   * Get Stats
   */
  async getStatsApiDbStatsGet(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<{ [key: string]: any }> {
    const response = await this.getStatsApiDbStatsGetRaw(initOverrides)
    return await response.value()
  }

  /**
   * Get trigger words for a local file by path.
   * Get Triggers By Path
   */
  async getTriggersByPathApiDbTriggersGetRaw(
    requestParameters: GetTriggersByPathApiDbTriggersGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string | null>>> {
    if (requestParameters['filePath'] == null) {
      throw new runtime.RequiredError(
        'filePath',
        'Required parameter "filePath" was null or undefined when calling getTriggersByPathApiDbTriggersGet().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['filePath'] != null) {
      queryParameters['file_path'] = requestParameters['filePath']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    const urlPath = `/api/db/triggers`

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Get trigger words for a local file by path.
   * Get Triggers By Path
   */
  async getTriggersByPathApiDbTriggersGet(
    requestParameters: GetTriggersByPathApiDbTriggersGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string | null>> {
    const response = await this.getTriggersByPathApiDbTriggersGetRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Get trigger words for a version by CivitAI version ID.
   * Get Triggers By Version
   */
  async getTriggersByVersionApiDbTriggersVersionIdGetRaw(
    requestParameters: GetTriggersByVersionApiDbTriggersVersionIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string | null>>> {
    if (requestParameters['versionId'] == null) {
      throw new runtime.RequiredError(
        'versionId',
        'Required parameter "versionId" was null or undefined when calling getTriggersByVersionApiDbTriggersVersionIdGet().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    let urlPath = `/api/db/triggers/{version_id}`
    urlPath = urlPath.replace(
      `{${'version_id'}}`,
      encodeURIComponent(String(requestParameters['versionId'])),
    )

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Get trigger words for a version by CivitAI version ID.
   * Get Triggers By Version
   */
  async getTriggersByVersionApiDbTriggersVersionIdGet(
    requestParameters: GetTriggersByVersionApiDbTriggersVersionIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string | null>> {
    const response = await this.getTriggersByVersionApiDbTriggersVersionIdGetRaw(
      requestParameters,
      initOverrides,
    )
    return await response.value()
  }

  /**
   * Link unlinked local files to CivitAI by hash lookup.
   * Link Files
   */
  async linkFilesApiDbLinkPostRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: any }>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    const urlPath = `/api/db/link`

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Link unlinked local files to CivitAI by hash lookup.
   * Link Files
   */
  async linkFilesApiDbLinkPost(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<{ [key: string]: any }> {
    const response = await this.linkFilesApiDbLinkPostRaw(initOverrides)
    return await response.value()
  }

  /**
   * List all local files with CivitAI info.
   * List Files
   */
  async listFilesApiDbFilesGetRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<{ [key: string]: any }>>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    const urlPath = `/api/db/files`

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * List all local files with CivitAI info.
   * List Files
   */
  async listFilesApiDbFilesGet(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<{ [key: string]: any }>> {
    const response = await this.listFilesApiDbFilesGetRaw(initOverrides)
    return await response.value()
  }

  /**
   * Scan directory for safetensor files and add to database.
   * Scan Directory
   */
  async scanDirectoryApiDbScanPostRaw(
    requestParameters: ScanDirectoryApiDbScanPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<{ [key: string]: any }>> {
    if (requestParameters['scanRequest'] == null) {
      throw new runtime.RequiredError(
        'scanRequest',
        'Required parameter "scanRequest" was null or undefined when calling scanDirectoryApiDbScanPost().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    const urlPath = `/api/db/scan`

    const response = await this.request(
      {
        path: urlPath,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: ScanRequestToJSON(requestParameters['scanRequest']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Scan directory for safetensor files and add to database.
   * Scan Directory
   */
  async scanDirectoryApiDbScanPost(
    requestParameters: ScanDirectoryApiDbScanPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<{ [key: string]: any }> {
    const response = await this.scanDirectoryApiDbScanPostRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Search cached models offline.
   * Search Models
   */
  async searchModelsApiDbModelsGetRaw(
    requestParameters: SearchModelsApiDbModelsGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<{ [key: string]: any }>>> {
    const queryParameters: any = {}

    if (requestParameters['query'] != null) {
      queryParameters['query'] = requestParameters['query']
    }

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type']
    }

    if (requestParameters['base'] != null) {
      queryParameters['base'] = requestParameters['base']
    }

    if (requestParameters['limit'] != null) {
      queryParameters['limit'] = requestParameters['limit']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['X-API-Key'] = await this.configuration.apiKey('X-API-Key') // APIKeyHeader authentication
    }

    if (this.configuration && this.configuration.apiKey) {
      queryParameters['api_key'] = await this.configuration.apiKey('api_key') // APIKeyQuery authentication
    }

    const urlPath = `/api/db/models`

    const response = await this.request(
      {
        path: urlPath,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Search cached models offline.
   * Search Models
   */
  async searchModelsApiDbModelsGet(
    requestParameters: SearchModelsApiDbModelsGetRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<{ [key: string]: any }>> {
    const response = await this.searchModelsApiDbModelsGetRaw(requestParameters, initOverrides)
    return await response.value()
  }
}
